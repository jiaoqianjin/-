# 注解与反射

## 一、注解

### 1. 什么是注解（Annotation)

Annotation是从JDK5.0开始引入的新技术；

Annotation的作用：

- 不是程序本身，可以对程序作出解释（这一点和注释（comment)没什么区别
- **可以被其他程序（比如：编译器等）读取**

Annotation的格式

- 注解是以“@注释名”在代码中存在的，还可以添加一些参数值，例如：@SuppressWarning(valut = "unchecked")

Annotation在哪里使用

- 可以附加在package，class , method , field 等上面，相当于给他们添加了额外的辅助信息。我们可以通过反射机制编程实现对这些元数据的访问。

### 2. 内置注解

![image-20200617214145049](https://gitee.com/jiao_qianjin/zhishiku/raw/master/img/20200617214153.png)

```java
// @SuppressWarnings("all")
public class text01  extends Object{

    @Override  // 重写的注解
    public String toString() {
        return super.toString();
    }

    @Deprecated  //程序员不鼓励使用的程序元素，通常是因为它是危险的，或者因为存在更好的替代方法。
    public static void test() {
        System.out.println("Deprecated");
    }
    @SuppressWarnings("all")  //镇压警告，表示该组警告被压制
    public void  test03() {
        List list = new ArrayList();
    }
    public static void main(String[] args) {
        test();
    }
}
```

- @SafeVarags
  抑制“堆污染”警告

```java

// 堆污染 引发 ClassCastException异常
List list = new ArrayList<>();
list.add(20);  // 添加元素时引发 unchecked异常
//引发“未经检查的转换”的警告，编译，运行时完全正常
List<String> ls = list;
// 只要访问ls 里面的元素，就会引起运行时异常
 System.out.println(ls.get(0));
```

抑制这个警告的方法

- 使用@SafeVarargs修饰引发该警告的方法或构造器
- 使用@SupperessWarning("unchecked")修饰
- 编译是使用-Xlint:varargs选项

@Functionallnterface

 	JAVA8 的函数式接口

### 3. 元注解

![image-20200617215435561](https://gitee.com/jiao_qianjin/zhishiku/raw/master/img/20200617215435.png)

```java
@MyAnnotation
public class test02 {
    public void test() {}
}

// 定义一个注解
// Target  表示我们的注解可以用在那个地方
@Target(value = {ElementType.METHOD,ElementType.TYPE})

// Retention 表示我们的注解在什么地方还有效
@Retention(value = RetentionPolicy.RUNTIME)

//@Documented  表示是否将我们的注解生成在JAVAdoc中
@Documented

//@Inherited 子类可以继承父类的注解
@Inherited
@interface MyAnnotation {
    
}
```

### 4. 自定义注解

Java使用`@interface`定义注解：

可定义多个参数和默认值，核心参数使用`value`名称；

必须设置`@Target`来指定`Annotation`可以应用的范围；

应当设置`@Retention(RetentionPolicy.RUNTIME)`便于运行期读取该`Annotation`。

![image-20200617221301372](https://gitee.com/jiao_qianjin/zhishiku/raw/master/img/20200617221301.png)

```java
// 自定义注解
public class test03 {
    @MyAnnotation2(name = "前进",age = 18)
    public void test01 () {

    }
    @MyAnnotation3("AAA") //只有一个值的情况下。注解中添加value,使用的时候可以省略
    public void test02 () {

    }
}

@Target({ElementType.METHOD,ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@interface MyAnnotation2 {
    // 注解的参数 ： 参数类型 + 参数名 （）
    String name() default "";
    int age();
    int id() default -1; // 如果默认值为-1，代表不存在

    String[] schools() default {"河南科技学院","园艺园林学院"};

}
@Target({ElementType.METHOD,ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@interface MyAnnotation3 {
    String value();
}
```









## 二、反射

通过`Class`实例获取`class`信息的方法称为反射（Reflection）。

### 1. Class

JVM为每个加载的`class`及`interface`创建了对应的`Class`实例来保存`class`及`interface`的所有信息；

- 获取一个`class`对应的`Class`实例后，就可以获取该`class`的所有信息；

- 通过Class实例获取`class`信息的方法称为反射（Reflection）；

- JVM总是动态加载`class`，可以在运行期根据条件来控制加载class。

### 2. 访问字段

Java的反射API提供的`Field`类封装了字段的所有信息：

- 通过`Class`实例的方法可以获取`Field`实例：`getField()`，`getFields()`，`getDeclaredField()`，`getDeclaredFields()`；‘

- 通过Field实例可以获取字段信息：`getName()`，`getType()`，`getModifiers()`；

- 通过Field实例可以读取或设置某个对象的字段，如果存在访问限制，要首先调用`setAccessible(true)`来访问非`public`字段。

- 通过反射读写字段是一种非常规方法，它会破坏对象的封装。

### 3.  调用方法

Java的反射API提供的Method对象封装了方法的所有信息：

- 通过`Class`实例的方法可以获取`Method`实例：`getMethod()`，`getMethods()`，`getDeclaredMethod()`，`getDeclaredMethods()`；

- 通过`Method`实例可以获取方法信息：`getName()`，`getReturnType()`，`getParameterTypes()`，`getModifiers()`；

- 通过`Method`实例可以调用某个对象的方法：`Object invoke(Object instance, Object... parameters)`；

- 通过设置`setAccessible(true)`来访问非`public`方法；

**通过反射调用方法时，仍然遵循多态原则。**

### 4. 调用构造方法

`Constructor`对象封装了构造方法的所有信息；

- 通过`Class`实例的方法可以获取`Constructor`实例：`getConstructor()`，`getConstructors()`，`getDeclaredConstructor()`，`getDeclaredConstructors()`；

- 通过`Constructor`实例可以创建一个实例对象：`newInstance(Object... parameters)`； 通过设置`setAccessible(true)`来访问非`public`构造方法。

### 5. 获取继承关系

通过`Class`对象可以获取继承关系：

- `Class getSuperclass()`：获取父类类型；
- `Class[] getInterfaces()`：获取当前类实现的所有接口。

通过`Class`对象的`isAssignableFrom()`方法可以判断一个向上转型是否可以实现。

### 6. 动态代理

Java标准库提供了动态代理功能，允许在运行期动态创建一个接口的实例；

动态代理是通过`Proxy`创建代理对象，然后将接口方法“代理”给`InvocationHandler`完成的。



----

## Java反射机制