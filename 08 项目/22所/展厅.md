# 方案调研

## 一、协议

### RS232

RS-232标准接口（又称EIA RS-232）是常用的[串行通信](https://baike.baidu.com/item/串行通信/324843)接口标准之一

### RS485

智能仪表随着80年代初单片机技术的成熟而发展起来，世界仪表市场基本被智能仪表所垄断，这归结于企业信息化的需要，而企业在仪表选型时其中的一个必要条件就是要具有联网[通信接口](https://baike.baidu.com/item/通信接口/9717922)。最初是数据模拟信号输出简单过程量，后来仪表接口是RS232接口，这种接口可以实现点对点的通信方式，但这种方式不能实现联网功能，随后出现的RS485解决了这个问题。

## 二、虚拟串口工具

[Virtual Serial Port Driver Pro(虚拟串口工具)汉化破解版 v6.9](http://www.xue51.com/soft/9349.html)

**irtual Serial Port Driver**是一款爱不释手的虚拟串口工具，其由著名软件公司Eltima开发，简称为VSPD，是虚拟串口软件中的佼佼者。

它支持快速调试代码、添加无限个虚拟串口、实时虚拟串口数据传输监控等多种功能，并且能够创建任何你想使用的端口号，一般情况下电脑上只有两个端口，但Virtual Serial Port Driver可以帮助你解除端口的限制，其目的是模拟使用虚拟串行端口驱动程序通过虚拟虚拟调制解调器电缆连接的RS232串行端口。

该驱动程序可以轻松包含在您自己的软件中，提供简单而强大的方式来创建和配置虚拟串行端口直接来自您的应用程序，使用VSPD XP，您可以在系统中创建任意数量的纯虚拟串行端口，并通过虚拟零调制解调器电缆成对连接，而无需占用实际的串行端口。

![image-20201213170327455](https://gitee.com/jiao_qianjin/zhishiku/raw/master/img/20201213170335.png)

## 三、RS232 Tool

[**RS232 Tool** 4.0 官方版](https://www.onlinedown.net/soft/632523.htm)

RS232 Tool是一款界面直观的串口通讯测试工具，适用于调试与检测各种智能仪表、PLC的串口通讯功能及工况，支持 RS232/RS485/RS422 接口及USB转串口通讯，具有指令表、数字标尺、通讯稳定性测试等特色功能。

![image-20201214081055922](https://gitee.com/jiao_qianjin/zhishiku/raw/master/img/20201214081056.png)

## 四、Java实现串口通信

### 1. 环境配置

http://fizzed.com/oss/rxtx-for-java

![image-20201213170851983](https://gitee.com/jiao_qianjin/zhishiku/raw/master/img/20201213170852.png)

下载后打开复制选中的两个文件到 /jre/bin 目录下

![image-20201213170938088](https://gitee.com/jiao_qianjin/zhishiku/raw/master/img/20201213170938.png)

### 3. 开始编程

#### **1. 新建**Maven**工程，导入rxtx依赖**

```xml
        <!-- 添加对485/232接口的依赖 -->
        <dependency>
            <groupId>org.rxtx</groupId>
            <artifactId>rxtx</artifactId>
            <version>2.1.7</version>
        </dependency>
```

#### 2. 查询可用串口

```java
/**
	 * 查找所有可用端口
	 *
	 * @return 可用端口名称列表
	 */
public static final ArrayList<String> findPorts() {
    // 获得当前所有可用串口
    Enumeration<CommPortIdentifier> portList = CommPortIdentifier.getPortIdentifiers();
    ArrayList<String> portNameList = new ArrayList<String>();
    // 将可用串口名添加到List并返回该List
    while (portList.hasMoreElements()) {
        String portName = portList.nextElement().getName();
        portNameList.add(portName);
    }
    return portNameList;
}
```

#### 3. 打开指定串口

```java
	/**
	 * 打开串口
	 *
	 * @param portName
	 *            端口名称
	 * @param baudrate
	 *            波特率
	 * @return 串口对象
	 * @throws PortInUseException
	 *             串口已被占用
	 */
public static final SerialPort openPort(String portName, int baudrate) throws PortInUseException {
    try {
        // 通过端口名识别端口
        CommPortIdentifier portIdentifier = CommPortIdentifier.getPortIdentifier(portName);
        // 打开端口，并给端口名字和一个timeout（打开操作的超时时间）
        CommPort commPort = portIdentifier.open(portName, 2000);
        // 判断是不是串口
        if (commPort instanceof SerialPort) {
            SerialPort serialPort = (SerialPort) commPort;
            try {
                // 设置一下串口的波特率等参数
                // 数据位：8
                // 停止位：1
                // 校验位：None
                serialPort.setSerialPortParams(baudrate, SerialPort.DATABITS_8, SerialPort.STOPBITS_1,
                                               SerialPort.PARITY_NONE);
            } catch (UnsupportedCommOperationException e) {
                e.printStackTrace();
            }
            return serialPort;
        }
    } catch (NoSuchPortException e1) {
        e1.printStackTrace();
    }
    return null;
}
```

#### 4. 接收/发送数据

```java
	/**
	 * 往串口发送数据
	 *
	 * @param serialPort
	 *            串口对象
	 * @param order
	 *            待发送数据
	 */
	public static void sendToPort(SerialPort serialPort, byte[] order) {
		OutputStream out = null;
		try {
			out = serialPort.getOutputStream();
			out.write(order);
			out.flush();
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
			try {
				if (out != null) {
					out.close();
					out = null;
				}
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
	}

	/**
	 * 从串口读取数据
	 *
	 * @param serialPort
	 *            当前已建立连接的SerialPort对象
	 * @return 读取到的数据
	 */
	public static byte[] readFromPort(SerialPort serialPort) {
		InputStream in = null;
		byte[] bytes = {};
		try {
			in = serialPort.getInputStream();
			// 缓冲区大小为一个字节
			byte[] readBuffer = new byte[1];
			int bytesNum = in.read(readBuffer);
			while (bytesNum > 0) {
				bytes = ArrayUtils.concat(bytes, readBuffer);
				bytesNum = in.read(readBuffer);
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
			try {
				if (in != null) {
					in.close();
					in = null;
				}
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
		return bytes;
	}
```

![image-20201214081735788](https://gitee.com/jiao_qianjin/zhishiku/raw/master/img/20201214081735.png)

## 五、串口网络中控播放器

### 1. 视频播放器 [v3.6](https://pan.baidu.com/s/1aF9fgl2s82bmPkoqddXnNg)

控制器

![image-20201213174937329](https://gitee.com/jiao_qianjin/zhishiku/raw/master/img/20201213174938.png)

![image-20201213175607208](https://gitee.com/jiao_qianjin/zhishiku/raw/master/img/20201213175607.png)

![image-20201213175628207](https://gitee.com/jiao_qianjin/zhishiku/raw/master/img/20201213175628.png)

### ![20201214081852](https://gitee.com/jiao_qianjin/zhishiku/raw/master/img/20201214082704.png)

### 2. 展厅智能中控

[展厅智能中控](http://www.show-m.cn/loadpage/)

![image-20201213180916536](https://gitee.com/jiao_qianjin/zhishiku/raw/master/img/20201213180916.png)

![image-20201214083919704](https://gitee.com/jiao_qianjin/zhishiku/raw/master/img/20201214083919.png)

## 六、调研展厅中控 如何用Java 实现

原理：
		所有的程序都要通过主机来控制，主机需要加上多种控制接头来连接控制设备，例如投影机、电源管理设备、灯光管理设备、音响等。当点击IPAD上的操作按钮时，IPAD会向控制主机发送相应的指令，连接着各个控制设备的主机就能做出相应的控制。

![image-20201214104124045](https://gitee.com/jiao_qianjin/zhishiku/raw/master/img/20201214104124.png)

## 七、问题

1. 音频调用场景？
2. 视频相关指令
3. 那么我们通过app通过无线网向交换机（中控主机）发送的是 接口请求参数 还是串口指令
4. 通过串口调试工具或者自己写的Demo 如何通过无线网向 主机发送串口指令，
5. 之前写了一个获取所有串口的demo,本地的虚拟串口都能获取到，但是通过连接到研究院的无线网，获取不到串口列表。

**解决思路**：

> 1. 调研web软件向控制电脑发送的是什么指令
> 2. 破解app ,查看向中控发送的是什么指令  (红外学习)
> 3. 本地模拟指令，向中控发送

## 八、测试指令

### 1. 串口管理

```shell
中控 192.168.50.240
1COM-音频处理
2COM-灯1
3COM-灯2
4COM-灯3
5COM-时序器
6COM-投影1
7COM-LED开关
8COM-    预留

9COM-屏9号
10COM-屏1
11COM-屏2
12COM-屏3
13COM-屏4
14COM-屏5  接扩展器1口也可以
15COM-屏6  接扩展器2口也可以
16COM-接扩展器

8口扩展控制器
1COM-屏5
2COM-屏6
3COM-屏7
4COM-屏8
5COM-屏10
6COM-屏11
7COM-屏12
8COM-屏13
```

### 2. 多功能卡控制电源开关

**控制第一路电源指令**

开启第一路电源指令

```shell
Request Command:    
	55 aa 00 4d  fe 00 00 00  00 00 01 00  10 00 00 05  01 00 00 b7  56 
Acknowledge Data Packet：
	aa 55 00 4d  00 fe 00 00  00 00 01 00  10 00 00 05  00 00 b6 56
```

关闭第一路电源指令

```shell
Request Command:   
	55 aa 00 4f  fe 00 00 00  00 00 01 00  10 00 00 05  01 00 01 ba  56 
Acknowledge Data Packet：
	aa 55 00 4f  00 fe 00 00  00 00 01 00  10 00 00 05  00 00 b8 56

```

### 3. 音频处理器控制协议

```shell
调用场景1： SET.SYS.SCENE.CALL(1);
调用场景2： SET.SYS.SCENE.CALL(2);
调用场景3： SET.SYS.SCENE.CALL(3);
...

从0开始，是第一路

减5DB    SET.OUT0.ADDVOL(-5);
加5DB    SET.OUT0.ADDVOL(5);
静音：   SET.OUT0.MUTE(1);
退出静音 SET.OUT0.MUTE(0);

减5DB    SET.OUT1.ADDVOL(-5);
加5DB    SET.OUT1.ADDVOL(5);
静音：   SET.OUT1.MUTE(1);
退出静音 SET.OUT1.MUTE(0);

...

设置输出通道1音量为-16.2dB  
指令： SET.OUT0.VOL(-16.2);

减1DB    SET.OUT0.ADDVOL(-1);
加1DB    SET.OUT0.ADDVOL(1);

设置输出通道1静音  
指令： SET.OUT0.MUTE(1);

设置输出通道1静音释放  
指令： SET.OUT0.MUTE(0);
```

### 4. 日立投影机 控制协议

```shell
波特率：19200，8，1，无奇偶较验
开机
BE EF 03 06 00 BA D2 01 00 00 60 01 00
关机
BE EF 03 06 00 2A D3 01 00 00 60 00 00
```

### 5. 时序器控制协议

```java
波特率24000  8 1   
55 01 00 0D F0 AA  全开
55 01 00 0D F1 AA  全关
```

### 6. 液晶大屏幕的开关机代码

```shell
屏幕1号到13号开关
开机命令74 0A 81
关机命令74 06 85

ID=30,COM=1,PARITY=N,9600,HEX,"740A81",END   屏开
ID=30,COM=1,PARITY=N,9600,HEX,"740685",END   屏关

ID=30,COM=2,PARITY=N,9600,HEX,"06010018021D",END   大屏1开
ID=30,COM=2,PARITY=N,9600,HEX,"06010018011E",END   大屏1关
ID=30,COM=3,PARITY=N,9600,HEX,"06010018021D",END   大屏2开
ID=30,COM=3,PARITY=N,9600,HEX,"06010018011E",END   大屏2关
```

### 7. 灯光继电器的代码 波特率 19200

```shell
第1路闭合:　96010B0101AA       第1路断开: 96010B0100AA
第2路闭合:　96010B0201AA       第2路断开: 96010B0200AA
第3路闭合:　96010B0301AA       第3路断开: 96010B0300AA
第4路闭合:　96010B0401AA       第4路断开: 96010B0400AA
第5路闭合:　96010B0501AA       第5路断开: 96010B0500AA
第6路闭合:　96010B0601AA       第6路断开: 96010B0600AA
第7路闭合:　96010B0701AA       第7路断开: 96010B0700AA
第8路闭合:　96010B0801AA       第8路断开: 96010B0800AA
八路全开:　96 01 0B 09 FF AA       八路全关: 96 01 0B 09 00 AA
9601010102030405AA  12345开
9601000102030405AA  12345关
```


## 九、扩展中控通信

为防止中控通信防止不止采用**RS232** 和**RS485**串口通信，所以通知利用 **java** 实现 **UDP** 和 **TCP** 通信

### 1. UDP 通信 客户端 发送指令

```java
package com.marchosft.udp;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;

/**
 * Description：UDP 通信 客户端
 *
 * @author jiaoqianjin
 * Date: 2020/12/14 15:55
 **/

public class Send {
    public static void main(String[] args) throws Exception {
        //通过DatagramSocket对象创建udp服务
        DatagramSocket ds = new DatagramSocket();
        //从键盘上面输入文本
        BufferedReader bufr =
                new BufferedReader(new InputStreamReader(System.in));
        String line;
        //当输入不为空时
        while ((line = bufr.readLine()) != null) {
            //当输入为byebye时退出程序
            if ("byebye".equals(line)) {
                break;
            }
            //确定好数据后，并把数据封装成数据包
            byte[] buf = line.getBytes();
            //发送至指定IP，指定端口
            DatagramPacket dp =
                    new DatagramPacket(buf, buf.length, InetAddress.getByName("192.168.133.1"), 9912);
            //通过send方法将数据包发送出去
            ds.send(dp);
        }
        ds.close();//关闭资源
    }
}

```

### 2. TCP 通信

```java
package com.marchosft.tcp;

import java.io.*;
import java.net.Socket;

/**
 * Description：TCP通信 客户端
 *
 * @author jiaoqianjin
 * Date: 2020/12/14 16:31
 **/

public class TCPClient {
    public static void main(String[] args) {

        //创建套接字对象,去请求服务器的ServerSocket
        Socket s = null;
        BufferedWriter writer = null;
        BufferedReader br;
        try {
            s = new Socket("192.168.133.1", 9913);
            //获得输出流
            OutputStream out = s.getOutputStream();
            //获得从控制台输入的流对象
            br = new BufferedReader(new InputStreamReader(System.in));
            writer = new BufferedWriter(new OutputStreamWriter(out));
            while (true) {
                System.out.println("请输入：");
                String line = br.readLine();
                writer.write(line);
                writer.newLine();
                writer.flush();
                //在退出程序之前一定要先换行再清空缓冲区
                if ("exit".equals(line)) {
                    System.out.println("程序已经退出");
                    break;
                }
            }

        } catch (Exception e) {
            e.printStackTrace();

        } finally {
            try {
                if (writer != null) {
                    writer.close();
                }
                if (s != null) {
                    s.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}

```

## 十、调试步骤

1. 网络互通

   通过连接展厅无线网接入，电视机，投影机，灯光等等组成的局域网。

2. 串口调试

   查找可用的串口列表，使用串口调试工具 RS232 Tool 和 代码调试。

   - 电路开关
   - 灯带开关
   - 电视机开关
   - 影片控制
   - 音频控制
   - 投影机控制

---

## 十一、第一次测试

网络不能互通

桑学长：

找到chome 软件装在哪一个服务器上，我们直接连接这个服务器，找到这些串口并发送指令

