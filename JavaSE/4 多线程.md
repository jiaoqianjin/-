# 多线程

## 1. 概述

普通线程和多线程

![image-20200809202858263](https://gitee.com/jiao_qianjin/zhishiku/raw/master/img/image-20200809202858263.png)

- 进程
  - 进程就是执行程序的一次执行过程,它是一个动态的概念,式系统资源分配的单位
  - 通常再一个进程中可以包含若干个线程,当然一个进程中至少有一个线程,不然没有存在的意义,线程是CPU调度和执行的单位
- 线程
  - **线程就是独立的执行路径**
  - 在程序运行时,即使没有自己创建线程,后台也会有多个线程,比如主线程,GC线程
  - main()称之为主线程,为系统的入口,用于执行整个程序
  - 在一个进程中,如果开辟了多个线程,线程的运行是由调度器安排调度的,调度器是与操作系统紧密相关的,先后顺序是不能人为干预的
  - 对同一份资源操作时mm会存在资源抢夺的问题,需要加入并发控制
  - 线程会带来额外的开销,如CPU调度时间,并发控制开销
  - 每个线程在自己的工作内存交互,内存控制不当会造成数据不一致

## 2. 线程创建

Thread  Runnable Callable

![image-20200809202350295](https://gitee.com/jiao_qianjin/zhishiku/raw/master/img/image-20200809202350295.png)

### 1）继承Thread类

```java
//对应P3  继承Threa实现线程
public class ThreadTest01 extends Thread {
    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName()+"执行了");
    }

    public static void main(String[] args) {
        ThreadTest01 threadTest01 = new ThreadTest01();
        threadTest01.start();
    }
}
```

### 2）实现Runnable接口

主要推荐这种方法实现线程，一个类的对象可以被多个线程使用

- 新建类继承Runnable接口后，就变成了线程类

- 重写run方法—线程的执行题
- 将线程类实例化丢给 Thread类的对象，然后对象启动start

```java
public class TestRunnable implements Runnable {
    @Override
    public void run() {
        System.out.println("实现了run方法");
    }
}

  public static void main(String[] args) {
        ThreadTest threadTest = new ThreadTest();
        threadTest.start();

        Thread thread = new Thread(new TestRunnable());
        thread.start();
    }

```

![image-20200809205623936](https://gitee.com/jiao_qianjin/zhishiku/raw/master/img/image-20200809205623936.png)

### 3）Callable

- 实现Callable接口,重写call方法,
- 可以定义返回值
- 可以抛出异常

```java
public class TestCallable implements Callable<Boolean> {
    @Override
    public Boolean call() throws Exception {
        System.out.println("创建成功");
        return true;
    }

    public static void main(String[] args) {
        TestCallable callable = new TestCallable();

        //创建执行服务
        ExecutorService service = Executors.newFixedThreadPool(1);
        //提交执行
        Future<Boolean> result = service.submit(callable);

        boolean isTrue = result.get();
        service.shutdownNow();

    }

}

```

## 3. 静态代理模式

- 真实角色和代理对象都要实现同一个接口
- 代理对象要代理真实角色

好处：

- 代理对象可以做很多真实角色做不了的事情
- 真实角色可以专注做自己的事情

```java
package mythread;

public class ThreadDemo {
	public static void main(String[] args) {
		WeddingCompany weddingCompany = new WeddingCompany(new You());
		weddingCompany.getMarry();
	}

}
interface Marry {
	void getMarry();
}

// 真实角色
class You implements Marry {

	@Override
	public void getMarry() {
		// TODO 自动生成的方法存根
		System.out.println("焦前进要结婚了，哈哈哈哈哈");
	}
}

//婚庆公司 代理对象，要去代理正式角色
class WeddingCompany implements Marry {
	
	private Marry target;
	
	WeddingCompany(Marry target) {
		this.target = target;
	}

	@Override
	public void getMarry() {
		// TODO 自动生成的方法存根
		
		before();
		this.target.getMarry();
		after();
		
	}

	private void after() {
		// TODO 自动生成的方法存根
		System.out.println("结婚前，布置现场");
		
	}

	private void before() {
		// TODO 自动生成的方法存根
		System.out.println("结婚后，清理");
		
	}
	
}
```

## 4. Lambda表达式

避免匿名内部类定义过多

其实质属于函数式编程的概念

可以让代码看起来很简洁

去掉了一堆没有意义的代码，只留下核心的逻辑

![image-20200809212653193](https://gitee.com/jiao_qianjin/zhishiku/raw/master/img/image-20200809212653193.png)

```java
package mythread;

public class LamdaDemo {
	// 2. 静态内部类
	static class Love2 implements Ilove{

		@Override
		public void lamda() {
			// TODO 自动生成的方法存根
			System.out.println("I Love lamda02");
		}
		
	}
	public static void main(String[] args) {
		Love1 love1 = new Love1();
		love1.lamda();
		
		Love2 love2 = new Love2();
		love2.lamda();
		
		// 3. 局部内部类
		class Love3 implements Ilove{

			@Override
			public void lamda() {
				// TODO 自动生成的方法存根
				System.out.println("I Love lamda03");
			}
			
		}
		Love3 love3 = new Love3();
		love3.lamda();
		
		// 4. 匿名内部类
		
		Ilove love4 = new Ilove() {
			
			@Override
			public void lamda() {
				// TODO 自动生成的方法存根
				System.out.println("I Love lamda04");
			}
		};
		love4.lamda();
		
		// 5. lamda表达式
		Ilove love5 = () -> {
			System.out.println("I Love lamda05");
		};
		love5.lamda();
	}

}
// 定义一个接口，只有一个方法，为函数式接口
interface Ilove{
	void lamda();
}

// 1. 外部类
class Love1 implements Ilove{

	@Override
	public void lamda() {
		// TODO 自动生成的方法存根
		System.out.println("I Love lamda01");
	}
	
}
```

1. lambda表达式只能有一行代码的情况下才能简化为一行，如果有多行，那么就用代码块包裹
2. 前提是接口为函数式接口
3. 多个参数也可以去掉参数类型，要去掉就都去掉，必须加上括号。

## 5. 线程状态

- 创建状态
- 就绪状态
- 阻塞状态
- 运行状态
- 死亡状态

![image-20200809215619971](https://gitee.com/jiao_qianjin/zhishiku/raw/master/img/image-20200809215619971.png)

### 1）线程停止

![image-20200809221614595](https://gitee.com/jiao_qianjin/zhishiku/raw/master/img/image-20200809221614595.png)

```java
public class TestStop implements Runnable {
    private boolean flag=true;
    @Override
    public void run() {
        int i=0;
        while (flag){
            System.out.println("run.....Thread"+(i++));
        }
    }
    public void stop(){
        this.flag=false;
    }

    public static void main(String[] args) {
        TestStop testStop = new TestStop();
        new Thread(testStop).start();
        for (int i = 0; i <1000 ; i++) {
            System.out.println("main"+i);
            if (i==900){
                testStop.stop();
                System.out.println("线程停止了！");
            }
        }
    }
}
```