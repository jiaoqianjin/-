# 操作系统



## 1. 进程与线程

### 1.1 进程

#### 1) 概念

**进程是操作系统分配存储资源的基本单位。**

进程是指运行中的应用程序，每个进程都有自己独立的地址空间（内存空间）。

比如用户点击桌面的IE浏览器，就启动了一个进程，操作系统就会为该进程分配独立的地址空间。当用户再次点击左边的IE浏览器，又启动了一个进程，操作系统将为新的进程分配新的独立的地址空间。目前操作系统都支持多进程。

#### 2) 进程的状态

1、就绪状态，英文称Ready。进程具备运行条件，等待系统分配处理器以便运行。

2、运行状态，英文称Running。进程占有处理器正在运行。

3、阻塞状态，英文称Blocked，指进程不具备运行条件，正在等待某个事件的完成。

### 1.2 线程

#### 1) 概念

线程是CPU调度的基本单位

进程是表示资源分配的基本单位。而线程则是进程中执行运算的最小单位，即执行处理机调度的基本单位。通俗来讲：一个程序有一个进程，而一个进程可以有多个线程。

#### 2) 线程的状态变化

​	**1、新建状态(New)**：新创建了一个线程对象。

​	**2、就绪状态(Runnable)**：线程对象创建后，其他线程调用了该对象的start()方法。该状态的线程位于“可运行线程池”中，变得可运行，只等待获取CPU的使用权，

  即在就绪状态的进程除CPU之外，其它的运行所需资源都已全部获得。

​	**3、运行状态(Running)**：就绪状态的线程获取了CPU，执行程序代码。

​	**4、阻塞状态(Blocked)**：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。

  阻塞的情况分三种：

​		①.等待阻塞：运行的线程执行wait()方法，该线程会释放占用的所有资源，JVM会把该线程放入“等待池”中。进入这个状态后，是不能自动唤醒的，必须依靠其他线程调用notify()或notifyAll()方法才能被唤醒，

​		②.同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入“锁池”中。

​		③.其他阻塞：运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时，或者I/O处理完毕时，线程重新转入就绪状态。

​	**5、死亡状态(Dead)**：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。

### 1.3 进程和线程有什么区别

​	1、进程要分配一大部分的内存，而线程只需要分配一部分栈就可以了。

​	2、一个程序至少有一个进程,一个进程至少有一个线程。

​	3、进程是资源分配的最小单位，线程是程序执行的最小单位。

​	4、一个线程可以创建和撤销另一个线程，同一个进程中的多个线程之间可以并发执行。

### 1.4 进程间的通信方式

**1、管道/匿名管道(Pipes)** 

​	用于具有亲缘关系的父子进程间或者兄弟进程之间的通信。

**2、有名管道(Names Pipes)** 

​	匿名管道由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道。有名管道严格遵循先进先出(first in first out)。有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。

**3、信号(Signal)** 

​	信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；

**4、消息队列(Message Queuing)** 

​	消息队列是消息的链表,具有特定的格式，存放在内存中并由消息队列标识符标识。

​	管道和消息队列的通信数据都是先进先出的原则。与管道（*无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统*）不同的是消息队列存放在内核中，只有在内核重启(*即，操作系统重启*)或者显示地删除一个消息队列时，该消息队列才会被真正的删除。消息队列可以实现消息的随机查询，消息不一定要以先进先出的次序读取，也可以按消息的类型读取。比 FIFO（*FIFO是英文First In First Out 的缩写，是一种先进先出的数据缓存器*） 更有优势。

​	消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺。

**5、信号量(Semaphores)** 

​	信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。

**6、共享内存(Shared memory)** 

​	使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是**最有用的进程间通信方式**。

**7、套接字(Sockets)**

​	此方法主要用于在客户端和服务器之间通过网络进行通信。套接字是支持 TCP/IP 的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。



### 1.5 线程间的同步的方式

**线程同步是两个或多个共享关键资源的线程的并发执行。使用**同步线程以避免关键的资源使用冲突。操作系统一般有下面三种线程同步的方式：

​	**1、互斥量(Mutex)：**采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。比如 Java 中的 synchronized 关键词和各种 Lock 都是这种机制。

​	**2、信号量(Semphares) ：**它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量

​	**3、事件(Event) :Wait/Notify：**通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作



### 1.6 进程的调度算法

**1、先到先服务(FCFS)调度算法：**

​	从就绪队列中选择一个最先进入该队列的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。

**2、短作业优先(SJF)的调度算法**：

​	从就绪队列中选出一个估计运行时间最短的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。

**3、时间片轮转调度算法**：

​	时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法，又称 RR(Round robin)调度。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。

**4、多级反馈队列调度算法**：

​	前面介绍的几种进程调度的算法都有一定的局限性。如短进程优先的调度算法，仅照顾了短进程而忽略了长进程 。多级反馈队列调度算法既能使高优先级的作业得到响应又能使短作业（进程）迅速完成。，因而它是**目前被公认的一种较好的进程调度算法**，UNIX 操作系统采取的便是这种调度算法。

**5、优先级调度**：

​	为每个流程分配优先级，首先执行具有最高优先级的进程，依此类推。具有相同优先级的进程以 FCFS 方式执行。可以根据内存要求，时间要求或任何其他资源要求来确定优先级。

## 2. 串行、并发、并行

### 2.1、串行

​	多个任务，执行时一个执行完再执行另一个。

​	比喻：吃完饭再看视频。

### 2.2、并发

​	多个线程在单个核心运行，同一时间一个线程运行，系统不停切换线程，看起来像同时运行，实际上是线程不停切换。

​	比喻： 一会跑去厨房吃饭，一会跑去客厅看视频。

### 2.3、并行

​	每个线程分配给独立的核心，线程同时运行。

​	比喻：一边吃饭一边看视频。

## 3. 死锁

### 3.1 什么是死锁

​	什么是死锁呢？打个比方，就好像有两个人打架，互相限制住了(锁住，抱住)彼此一样，互相动弹不得，而且互相欧气，你不松手我就不松手。好了谁也动弹不得。

​	在多线程的环境下，势必会对资源进行抢夺。当两个线程锁住了当前资源，但都需要对方的资源才能进行下一步操作，这个时候两方就会一直等待对方的资源释放。这就形成了死锁。这些永远在互相等待的进程称为死锁进程。

### 3.2 死锁产生的条件

1. **互斥：**资源的锁是排他性的，加锁期间只能有一个线程拥有该资源。其他线程只能等待锁释放才能尝试获取该资源。
2. **请求和保持：**当前线程已经拥有至少一个资源，但其同时又发出新的资源请求，而被请求的资源被其他线程拥有。此时进入保持当前资源并等待下个资源的状态。
3. **不剥夺：**线程已拥有的资源，只能由自己释放，不能被其他线程剥夺。
4. **循环等待：**是指有多个线程互相的请求对方的资源，但同时拥有对方下一步所需的资源。形成一种循环，类似2)请求和保持。但此处指多个线程的关系。并不是指单个线程一直在循环中等待。

### 3.3 如何解决死锁

死锁一旦发生，我们就无法解决了。所以我们只能避免死锁的发生。

既然死锁需要满足四种条件，那我们就从条件下手，只要打破任意规则即可。



1. （互斥）尽量少用互斥锁，能加读锁，不加写锁。当然这条无法避免。
2. （请求和保持）采用资源静态分配策略（进程资源静态分配方式是指一个进程在建立时就分配了它需要的全部资源）.我们尽量不让线程同时去请求多个锁，或者在拥有一个锁又请求不到下个锁时，不保持等待，先释放资源等待一段时间在重新请求。
3. （不剥夺）允许进程剥夺使用其他进程占有的资源。优先级。
4. （循环等待）尽量调整获得锁的顺序，不发生嵌套资源请求。加入超时。



## 4. 缓存缓冲

### 4.1 什么是缓存区，缓存区溢出？

1. **缓冲区(buffer)**

   它是内存空间的一部分。也就是说，在内存空间中预留了一定的存储空间，这些存储空间用来缓冲输入或输出的数据，这部分预留的空间就叫做缓冲区，显然缓冲区是具有一定大小的。

   缓冲区根据其对应的是输入设备还是输出设备，分为输入缓冲区和输出缓冲区

2. **缓冲区溢出**

   是指当计算机向缓冲区填充数据时超出了缓冲区本身的容量，溢出的数据覆盖在合法数据上。



### 4.2 **缓存（cache）与缓冲(buffer)的主要区别**

​	Buffer的核心作用是用来缓冲，缓和冲击。比如你每秒要写100次硬盘，对系统冲击很大，浪费了大量时间在忙着处理开始写和结束写这两件事嘛。用个buffer暂存起来，变成每10秒写一次硬盘，对系统的冲击就很小，写入效率高了，日子过得爽了。极大缓和了冲击。

​	Cache的核心作用是加快取用的速度。比如你一个很复杂的计算做完了，下次还要用结果，就把结果放手边一个好拿的地方存着，下次不用再算了。加快了数据取用的速度。

​	简单来说就是buffer偏重于写，而cache偏重于读。缓冲：缓解冲击，缓存：临时存储。



## 5. 分段与分页机制

### 5.1 分页

​	分页式存储管理，将用户程序的地址空间分成若干个**固定大小**的区域，称为页或者页面，这样可以将用户程序的页放入任一物理块中，而不用担心碎片的产生。

### 5.2 分段

​	分段式存储是为了满足用户要求而形成的一种存储管理方式，它是把用户程序分成若干个大小不同的段，这些段可以不相邻，所以也实现了离散分配。

### 5.3 段页式

​	综合分页和分段两种方式，目前应用最广的一种存储方式。

### 5.4 分页和分段的区别

两者的概念完全不同，体现以下三方面：

1. 页是信息的物理单位。采用分页是为了消除内存碎片，提高内存利用率，仅仅是系统的行为，对用户是不可见的，而分段的目的主要是为了更好地满足用户的需要
2. 页的大小固定且由系统决定，这个页的大小是由硬件实现的，所以每个系统只有一种页的大小。段的大小是不固定的，由用户编写的程序划分。
3. 分页的用户程序地址空间是一维的。分页是系统决定的，所以在分页系统中用户程序地址是线性分布的。而分段是用户行为，所以在分段系统中用户程序地址是二维的，既要给出段名又要给出段内地址。

## 6. CPU上下文切换

### 6.1 什么是CPU上下文