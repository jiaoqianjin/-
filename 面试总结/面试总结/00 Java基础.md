

# Java基础

[Java 全栈知识体系](https://www.pdai.tech/)

著作权归https://pdai.tech所有。 链接：https://www.pdai.tech/md/java/thread/java-thread-x-thread-basic.html

[并发编程面试题（2020最新版）](https://thinkwon.blog.csdn.net/article/details/104863992)

版权声明：本文为CSDN博主「ThinkWon」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/ThinkWon/article/details/104863992

[JavaGuide](https://javaguide.cn/)

## 一、面向对象

### 1.1 面向对象和面向过程的区别

#### 1.1.1 面向过程

**面向过程是具体化的，流程化的，解决一个问题，你需要一步一步的分析，一步一步的实现。**

**优点：**性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发，性能是最重要的因素。

**缺点：**没有面向对象易维护、易复用、易扩展

#### 1.1.2 面向对象

**面向对象是模型化的，你只需抽象出一个类，这是一个封闭的盒子，在这里你拥有数据也拥有解决问题的方法。需要什么功能直接使用就可以了，不必去一步一步的实现，至于这个功能是如何实现的，管我们什么事？我们会用就可以了**

**优点：**易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护

**缺点：**性能比面向过程低

### 1.2 面向对象的三大特性	

#### 1.2.1 封装

​	隐藏对象的属性和实现细节，仅对外提供公共访问方式，将变化隔离，便于使用，提高复用性和安全性。

#### 1.2.2 继承

​	继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承可以提高代码复用性。继承是多态的前提。

**特点：**

1. 子类拥有父类非 private 的属性和方法。
2. 子类可以拥有自己属性和方法，即子类可以对父类进行扩展。
3. 子类可以用自己的方式实现父类的方法。

#### 1.2.3 多态

多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。

多态分为**编译时多态**和**运行时多态**:

- 编译时多态主要指方法的**重载**
  - 发生在同一个类中（或者父类和子类之间），方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。
- 运行时多态指程序中定义的对象引用所指向的具体类型在运行期间才确定

**运行时多态**有三个条件:

- 继承：在多态中必须存在有继承关系的子类和父类。
- **覆盖(重写)**：类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。
  1. 返回值类型、方法名、参数列表必须相同，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。
  2. 如果父类方法访问修饰符为 `private/final/static` 则子类就不能重写该方法，但是被 static 修饰的方法能够被再次声明。
  3. 构造方法无法被重写
- 向上转型：多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法。

​	

## 二、基础语法

### 2.1 访问修饰符

#### 2.1.1 定义

Java中，可以使用访问修饰符来保护对类、变量、方法和构造方法的访问。Java 支持 4 种不同的访问权限。

#### 2.1.2 分类

- **private** : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类）
- **default (即缺省，什么也不写，不使用任何**关键字）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。
- **protected** : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类）。
- **public** : 对所有类可见。使用对象：类、接口、变量、方法

#### 2.1.3 访问修饰符图

![img](https://gitee.com/jiao_qianjin/zhishiku/raw/master/img/20211118205823.png)

### 2.2 关键字

#### 2.2.1 static

**存在意义**

1. static的主要意义是在于创建独立于具体对象的域变量或者方法。以致于即使没有创建对象，也能使用属性和调用方法！

2. static关键字还有一个比较关键的作用就是 用来形成静态代码块以优化程序性能。static块可以置于类中的任何地方，类中可以有多个static块。在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次。

**特点**

1. 被static修饰的变量或者方法是独立于该类的任何对象，也就是说，这些变量和方法**不属于任何一个实例对象，而是被类的实例对象所共享**。
2. static变量值在类加载的时候分配空间，以后创建类对象的时候不会重新分配。赋值的话，是可以任意赋值的！静态变量在内存中只存在一份。
3. 被static修饰的变量或者方法是优先于对象存在的，也就是说当一个类加载完毕之后，即便没有创建对象，也可以去访问。可以直接通过类名来访问它。

**应用场景**

因为static是被类的实例对象所共享，因此如果**某个成员变量是被所有对象所共享的，那么这个成员变量就应该定义为静态变量**。

1. 修饰成员变量 
2. 修饰成员方法 
3. 静态代码块 
4. 修饰类【只能修饰内部类也就是静态内部类】
5. 静态导包

**注意事项**

1. 静态只能访问静态。 
2. 非静态既可以访问非静态的，也可以访问静态的。

#### 2.2.2 final

**1. 数据**

声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。

- 对于基本类型，final 使数值不变；
- 对于引用类型，final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。

**2. 方法**

**声明方法不能被子类重写。**

private 方法隐式地被指定为 final，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法。

**3. 类**

**声明类不允许被继承。**

## 三、泛型

### 3.1 为什么使用泛型

**适用于多种数据类型执行相同的代码**（代码复用）

### 3.2 泛型的类型擦除

#### 3.2.1 伪泛型

Java泛型这个特性是从JDK 1.5才开始加入的，因此为了兼容之前的版本，Java泛型的实现采取了“**伪泛型**”的策略，即Java在语法上支持泛型，但是在编译阶段会进行所谓的“**类型擦除**”（Type Erasure），将所有的泛型表示（尖括号中的内容）都替换为具体的类型（其对应的原生态类型），就像完全没有泛型一样。

#### 3.2.2 类型擦除原则

- 消除类型参数声明，即删除`<>`及其包围的部分。
- 根据类型参数的上下界推断并替换所有的类型参数为原生态类型：如果类型参数是无限制通配符或没有上下界限定则替换为Object，如果存在上下界限定则根据子类替换原则取类型参数的最左边限定类型（即父类）。
- 为了保证类型安全，必要时插入强制类型转换代码。
- 自动产生“桥接方法”以保证擦除类型后的代码仍然具有泛型的“多态性”。

#### 3.2.3 如何擦除

- 擦除类定义中的类型参数 - 无限制类型擦除

  当类定义中的类型参数没有任何限制时，在类型擦除中直接被替换为Object，即形如`<T>`和`<?>`的类型参数都被替换为Object。

![img](https://gitee.com/jiao_qianjin/zhishiku/raw/master/img/20211120111158.png)



- 擦除类定义中的类型参数 - 有限制类型擦除

  当类定义中的类型参数存在限制（上下界）时，在类型擦除中替换为类型参数的上界或者下界，比如形如`<T extends Number>`和`<? extends Number>`的类型参数被替换为`Number`，`<? super Number>`被替换为Object。

![img](https://gitee.com/jiao_qianjin/zhishiku/raw/master/img/20211120111249.png)



- 擦除方法定义中的类型参数

  ![img](https://gitee.com/jiao_qianjin/zhishiku/raw/master/img/20211120111319.png)

### 3.3 编译期检查

> 既然说类型变量会在编译的时候擦除掉，那为什么我们往 ArrayList 创建的对象中添加整数会报错呢？不是说泛型变量String会在编译的时候变为Object类型吗？为什么不能存别的类型呢？既然类型擦除了，如何保证我们只能使用泛型变量限定的类型呢？

Java编译器是通过先检查代码中泛型的类型，然后在进行类型擦除，再进行编译。

## 四、数据类型

### 1. 基本数据类型

- ### Java 中的几种基本数据类型是什么？对应的包装类型是什么？各自占用多少字节呢？

  Java 中有 8 种基本数据类型，分别为：

  1. 6 种数字类型 ：`byte`、`short`、`int`、`long`、`float`、`double`
  2. 1 种字符类型：`char`
  3. 1 种布尔型：`boolean`。

  这 8 种基本数据类型的默认值以及所占空间的大小如下：

  | 基本类型  | 位数 | 字节 | 默认值  |
  | :-------- | :--- | :--- | :------ |
  | `int`     | 32   | 4    | 0       |
  | `short`   | 16   | 2    | 0       |
  | `long`    | 64   | 8    | 0L      |
  | `byte`    | 8    | 1    | 0       |
  | `char`    | 16   | 2    | 'u0000' |
  | `float`   | 32   | 4    | 0f      |
  | `double`  | 64   | 8    | 0d      |
  | `boolean` | 1    |      | false   |

  另外，对于 `boolean`，官方文档未明确定义，它依赖于 JVM 厂商的具体实现。逻辑上理解是占用 1 位，但是实际中会考虑计算机高效存储因素。

### 2. 自动装箱与拆箱

- **装箱**：将基本类型用它们对应的引用类型包装起来；
- **拆箱**：将包装类型转换为基本数据类型；

举例：

```java
Integer i = 10;  //装箱
int n = i;   //拆箱
```

### 3. 缓存池

Java 基本类型的包装类的大部分都实现了常量池技术。`Byte`,`Short`,`Integer`,`Long` 这 4 种包装类默认创建了数值 **[-128，127]** 的相应类型的缓存数据，`Character` 创建了数值在[0,127]范围的缓存数据，`Boolean` 直接返回 `True` Or `False`。

new Integer(123) 与 Integer.valueOf(123) 的区别在于:

- new Integer(123) 每次都会新建一个对象
- Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。

**基本类型对应的缓冲池如下:**

- boolean values true and false
- all byte values
- short values between -128 and 127
- int values between -128 and 127
- char in the range \u0000 to \u007F

在使用这些基本类型对应的包装类型时，就可以直接使用缓冲池中的对

## 五、String

### 5.1 基本概念

**String 被声明为 final，因此它不可被继承。**

内部使用 char 数组存储数据，该数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保 String 不可变。

```java
public final class String
    implements java.io.Serializable, Comparable<String>, CharSequence {
    /** The value is used for character storage. */
    private final char value[];
```

### 5.2 String的优势

1. **可以缓存 hash 值**

   因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。

2. **安全性**

​	String 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 对象的那一方以为现在连接的是其它主机，而实际情况却不一定是。

3. **线程安全**

   String 不可变性天生具备线程安全，可以在多个线程中安全地使用。

### 5.3 String, StringBuffer and StringBuilder

#### 1. 可变性

- String 不可变
- StringBuffer 和 StringBuilder 可变

#### 2. 线程安全

- String 不可变，因此是线程安全的
- StringBuilder 不是线程安全的
- StringBuffer 是线程安全的，内部使用 synchronized 进行同步

### 5.4 String.intern()

使用 String.intern() 可以保证相同内容的字符串变量引用同一的内存对象。

下面示例中，s1 和 s2 采用 new String() 的方式新建了两个不同对象，而 s3 是通过 s1.intern() 方法取得一个对象引用。intern() 首先把 s1 引用的对象放到 String Pool(字符串常量池)中，然后返回这个对象引用。因此 s3 和 s1 引用的是同一个字符串常量池的对象。

```java
String s1 = new String("aaa");
String s2 = new String("aaa");
System.out.println(s1 == s2);           // false
String s3 = s1.intern();
System.out.println(s1.intern() == s3);  // true
```

