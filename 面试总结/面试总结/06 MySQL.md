# MySQL

## 常见问题

### 1. 怎么优化一个慢查询

#### 1. 什么是慢查询

**MySQL慢查询就是在日志中记录运行比较慢的SQL语句**，这个功能需要开启才能用。

在MySQL的配置文件my.cnf中写上：

```cpp
long_query_time = 10
log-slow-queries = /var/lib/mysql/mysql-slow.log
```

`long_query_time`是指执行超过多久的SQL会被日志记录下来，这里是10 秒。
`log-slow-queries`设置把日志写在那里（例子中慢查询日志会写到文件/var/lib/mysql/mysql-slow.log中），为空的时候，系统会给慢查询日志赋予主机名，并加上slow.log。如果设置了参数log-long-format ，那么所有没有使用索引的查询也将被记录。

这是一个非常有用的日志。它对于性能的影响不大（假设所有查询都很快），并且强调了那些最需要注意的查询（丢失了索引或索引没有得到最佳应用）。

#### 2. 查询SQL为什么慢

​	我们可以把查询SQL执行看做是一个任务的话，那它是由一些列子任务组成的，每个子任务都存在一定的时间消耗。通常情况下，导致慢查询最根本的问题就是需要访问的数据太多，导致查询不可避免的需要筛选大量的数据。

​	面对慢查询，我们需要注意以下两点：

- 查询了过多不需要的数据

- 扫描了额外的记录

##### 3.1 **查询了过多不需要的数据**

​	MySQL并不是只返回需要的数据，实际上会返回全部结果集再进行计算。

​	尤其是多表关联查询 select * 的情况，我们是不是真的需要全部的列呢？如果不是，那我们**直接指定对应字段就好了**。

​	取出全部列，会让优化器无法完成索引覆盖扫描这类优化，还会为服务器带来额外的I/O、内存和CPU的消耗。

##### 3.2 扫描了额外的记录

​	此种情况大部分属于索引应用不当造成的（包括：应该建的索引没有建，或者未应用到最佳索引）。

​	示例表结构如下：

```SQL
CREATE TABLE test_table (
  name varchar(32) DEFAULT NULL,
  desc varchar(32) DEFAULT NULL,
  age int(16) DEFAULT NULL,
  id bigint(11) DEFAULT NULL,
  KEY idx_age (age)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```

​	存在索引 `idx_age` 的情况下，查询执行计划结果展示如下：

```sql
EXPLAIN SELECT * FROM test_table WHERE age = 10;
```

​	预估访问1行数据即可命中数据，如删除有效索引 `idx_age` 后则会变成全表扫描（ALL），预估需要扫描表中全部记录才能完成这个查询

#### 3. 如何定位慢查询

 直接分析mysql慢查询日志 ,利用explain关键字可以模拟优化器执行SQL查询语句，来分析sql慢查询语句。

通常我们**使用EXPLAIN**，会得到如下下的执行计划信息

![image-20211110152413751](https://gitee.com/jiao_qianjin/zhishiku/raw/master/img/20211110152436.png) 

关于定位分析问题，关键看如下几点：

1）**select_type**

表示查询类型，用于区别普通查询、联合查询、子查询等复杂查询。

2）**type**

显示查询使用类型，从好到差依次为：system > const > eq_ref > ref > range > **index > all**

如果发现type的值是最后两个中的其中一个时，证明语句需要优化了。

3）**possible_keys 和 key**

分别指可能应用的索引和实际应用的索引。

注意：查询中若使用了覆盖索引（select 后要查询的字段刚好和创建的索引字段完全相同），则该索引仅出现在key列表中。

4）**rows**

大致估算出找到所需记录所需要读取的行数（从效率上来讲，数值越小越好）

5）**Extra**

重要的额外信息。包含MySQL解决查询的详细信息，也是关键参考项之一。不太友好的值有：Using filesort, Using temporary。

#### 4. 如何优化慢查询

对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。

**避免索引失效**

- **使用**`**!=**` **或者** `**<>**` **导致索引失效**。
- **类型不一致导致的索引失效**。
- **函数导致的索引失效**。如：`SELECT * FROM user WHERE DATE(create_time) = '2020-09-03';` 如果`create_time`添加了索引，索引会失效。
- **运算符导致的索引失效**。如：`SELECT * FROM user WHERE age - 1 = 20;` 如果对列进行了（+，-，*，/，!）, 那么都将不会走索引。
- `**OR**`**引起的索引失效**。OR导致索引是在特定情况下的，并不是所有的OR都是使索引失效，如果OR连接的是同一个字段，那么索引不会失效，反之`OR`右侧字段索引失效。
- **模糊搜索导致的索引失效**。当`%`放在匹配字段前是不走索引的，放在后面才会走索引。
- `**NOT IN**`**、**`**NOT EXISTS**`**导致索引失效**。

### 2. 主从复制、读写分离

#### 2.1 为什么使用主从复制、读写分离

**主从复制、读写分离是为了数据库能够支持更大的并发**

随着业务量的扩展，如果是单机部署的MySQL，会导致I/O频率过高。采用**主从复制、读写分离可以提高数据库的可用性。**

#### 2.2 主从复制原理

1. 当**Master**执行insert,delete,update操作时，会按顺序写入**binlog**中；
2. **Salve**从库连接**master**主库，**Master**有多少个**Salve**就会创建多少个**binlong dump**线程；
3. 当**Master**节点的**binlog**发生变化时，**binlog dump** 线程会通知所有的**salve**节点，并将相应的**binglog**内容推送给**Salve**节点；
4. **Salve**节点的**I/O**线程接收到**binlog**内容后，将内容写入到本地的**relay-log**;
5. **SQL**线程读取**I/O线程写入的relay-log**，并且根据relay-log的内容对从数据库做对应的操作。

#### 2.3 主从复制、读写分离存在的问题

1. **网络延迟**

   **问题描述：**

   ​	从机是通过binlog日志从master同步数据的，如果在网络延迟的情况，从机就会出现数据延迟。那么就有可能出现master写入数据后，slave读取数据不一定能马上读出来。

   **解决方法：**

   ​	ShardingSphere-JDBC框架在实现读写分离的时候已经考虑到了该问题，它的解决方式为：

   同一线程且同一数据库连接内，如有写入操作，以后的操作均从主库读取，用户保证数据一致性

2. **主从同步延时**

   **问题描述：**

   ​	从库同步主库数据的过程是串行化的，也就是说主库上并行的操作，在从库上会串行执行。所以这就是一个非常重要的点了，由于从库从主库拷贝日志以及串行执行 SQL 的特点，在高并发场景下，从库的数据一定会比主库慢一些，是**有延时**的。所以经常出现，刚写入主库的数据可能是读不到的，要过几十毫秒，甚至几百毫秒才能读取到。

   **解决方法：**

   ​	**并行复制**，指的是从库开启多个线程，并行读取 relay log 中不同库的日志，然后**并行重放不同库的日志？**，这是库级别的并行。

3. 主库数据丢失

   **问题描述：**

   ​	如果主库突然宕机，然后恰好数据还没同步到从库，那么有些数据可能在从库上是没有的，有些数据可能就丢失了。

   **解决方法：**

   ​	**半同步复制**，也叫`semi-sync`复制，指的就是主库写入 binlog 日志之后，就会将**强制**此时立即将数据同步到从库，从库将日志写入自己本地的 relay log 之后，接着会返回一个 ack 给主库，主库接收到**至少一个从库**的 ack 之后才会认为写操作完成了。

### 3. MySQL最左前缀原则

1. 如果你创建一个联合索引, 那这个索引的任何前缀都会用于查询,` (col1, col2, col3)`这个联合索引的所有前缀 就是`(col1), (col1, col2)`, `(col1, col2, col3)`, 包含这些列的查询都会启用索引查询，值得注意的是，当遇到范围查询(>、<、between、like)就会停止匹配。
2.  其他所有不在最左前缀里的列都不会启用索引, 即使包含了联合索引里的部分列也不行. 即上述中的`(col2)`, `(col3), (col2, col3) `都不会启用索引去查询.
    **注意, (col1, col3)会启用(col1)的索引查询**

**最左前缀原则原理**

最左匹配原则是针对联合索引来说的，所以我们有必要了解一下联合索引的原理。

索引的底层是一颗B+树，联合索引也是一颗B+树。只不过联合所有的键值数量不是一个，而是多个，构建一颗B+树只能根据一个值来构建，因此数据库依据联合索引最左的字段来构建B+树。

例子：假如创建一个（a,b)的联合索引，那么它的索引树是这样的

![在这里插入图片描述](https://gitee.com/jiao_qianjin/zhishiku/raw/master/img/20211110171603.png)

可以看到a的值是有顺序的，1，1，2，2，3，3，而b的值是没有顺序的1，2，1，4，1，2。所以b = 2这种查询条件没有办法利用索引，因为联合索引首先是按a排序的，b是无序的。

同时我们还可以发现在a值相等的情况下，b值又是按顺序排列的，但是这种顺序是相对的。所以**最左匹配原则遇上范围查询就会停止**，剩下的字段都无法使用索引。例如a = 1 and b = 2 a,b字段都可以使用索引，因为在a值确定的情况下b是相对有序的，而a>1and b=2，a字段可以匹配上索引，但b值不可以，因为a的值是一个范围，在这个范围中b是无序的。