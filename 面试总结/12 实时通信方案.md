# 实时通信方案

## 一、通信方案

### 1. 短轮询

#### 1.1.1 简介

短轮询原理很简单，即客户端定时的向服务端发送请求，如果服务端有数据返回，则返回数据，否则返回空数据。

#### 1.1.2 存在问题

- 如果想要实时性好，则必须轮询间隔短，但会有大量的请求是无效的（返回空数据），

- 如果轮询间隔长，则实时性不好，数据达到客户端的延时最大会趋近于轮询间隔。

**多次请求不仅浪费资源，而且并不是实时的更新。**

### 2. 长轮询

#### 1.2.1 简介

长轮询即服务器端接收到请求后，会阻塞请求直到有数据或者超时（20S）才返回，浏览器JS在处理请求返回消息（超时或有效数据）后再次发送请求，重新建立连接

#### 1.2.2 处理方式

服务器内部接收到请求后可以选择2种处理方式

1. 循环查询是否有新数据
2. 基于事件驱动，当有新数据后与客户端响应

#### 1.2.3 存在问题

**服务器hold连接会消耗资源，需要同时维护多个线程，服务器所能承载的TCP连接数是有上限的，这种轮询很容易把连接数顶满。**

### 3. SSE

#### 1.3.1 简介

SSE(Server-Sent Events): 通俗解释起来就是一种基于HTTP的，以流的形式由服务端持续向客户端发送数据的技术

**SSE的简单模型是：**一个客户端去从服务器端订阅一条“流”，之后服务端可以发送消息给客户端直到服务端或者客户端关闭该“流”，所以SSE全称叫“server-sent-event”。

#### 1.3.2 处理方式

服务器产生最新的数据后向客户端推动数据，SSE只能单向通信，建立连接后，只能由服务端发往客户端，且占用一个连接，如需用户端向服务端通行，需额外打开一个连接；

#### 1.3.3 使用场景

在股票行情、新闻推送的这种只需要服务器发送消息给客户端场景中，使用SSE可能更加合适。

#### 1.3.4 优缺点

**优点**

- SSE是使用HTTP传输的，这意味着我们不需要一个特殊的协议或者额外的实现就可以使用。而WebSocket要求全双工连接和一个新的WebSocket服务器去处理。
- SSE在设计的时候就有一些WebSocket没有的特性，比如自动重连接、event IDs、以及发送随机事件的能力

**缺点**

- 因为是服务器 -> 客户端的，所以它不能处理客户端请求流；
- 因为是明确指定用于传输UTF-8数据的，所以对于传输二进制流是低效率的，即使你转为base64的话，反而增加带宽的负载，得不偿失。

所以`SSE`与`WebSocket`各有各的特长，我们需要根据实际应用场景，去选择不同的应用方案。

### 4. WebSocket

#### 1.4.1 简介

WebSocket是一种在单个TCP连接上进行全双工通信的协议。允许服务端主动向客户端推送数据。客户端和服务端只需要完成一次握手，两者之间直接可以创建持久性的连接，并进行双向数据传输

#### 1.4.2 处理方式

服务产生最新的数据后向客户端推送数据，向服务端推数据，只要连接不断开，就可以随时完成客户端与服务端的通信工作。

## 二、Netty+WebSocket

### 2.1 什么是Netty

1. Netty是一个高性能NIO框架，所以它是基于NIO基础上的封装，提供了一个简单易用的APi，我们可以利用这些APi快速的开发自己的一个网络程序
2. Netty在NIO的基础上做了很多的优化，比如零拷贝机制，高性能无锁队列，内存池等，因此性能比NIO更高
3. Netty支持多种通信协议，http,websocket等，并且针对数据通信的拆包粘包，Netty内置了拆包策略，在使用过程中会比较方便

### 2.2 为什么要使用Netty

Netty提供了Reactor模型的支持，我们可以通过Netty封装好的API来快速完成不同Reactor模型的开发，这也是为什么大家都选择Netty的原因之一，除此之外，Netty相比于NIO原生API，它有以下特点：

- 提供了高效的I/O模型、线程模型和时间处理机制

- 提供了非常简单易用的API，相比NIO来说，针对基础的Channel、Selector、Sockets、Buffers等api提供了更高层次的封装，屏蔽了NIO的复杂性

- 对数据协议和序列化提供了很好的支持

- 稳定性，Netty修复了JDK NIO较多的问题，比如select空转导致的cpu消耗100%、TCP断线重连、keep-alive检测等问题。

- 可扩展性在同类型的框架中都是做的非常好的，比如一个是可定制化的线程模型，用户可以在启动参数中选择Reactor模型、 可扩展的事件驱动模型，将业务和框架的关注点分离。

- 性能层面的优化，作为网络通信框架，需要处理大量的网络请求，必然就面临网络对象需要创建和销毁的问题，这种对JVM的GC来说不是很友好，为了降低JVM垃圾回收的压力，引入了两种优化机制

- - 对象池复用，
  - 零拷贝技术